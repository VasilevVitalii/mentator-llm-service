<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat - Mentator LLM Service</title>
    <link rel="stylesheet" href="/static/css/common.css">
</head>
<body>
    <div id="app">
        <div class="banner">
            <div class="banner-title">
                <a href="/">MENTATOR-LLM-SERVICE, VERSION {{ version }}</a>
            </div>
            <div class="banner-subtitle">chat</div>
        </div>

        <div class="main-content">
            <div class="chat-container">
                <!-- Top section -->
                <div class="chat-top-section" :style="{ height: topHeight + 'px' }">
                    <!-- Row 1: Type, Model, Format, Options -->
                    <div class="form-row">
                        <div class="form-group fixed-width">
                            <span class="form-label">message type</span>
                            <select v-model="messageType" class="form-select" :disabled="isSending">
                                <option value="system">system</option>
                                <option value="user">user</option>
                            </select>
                        </div>
                        <div class="form-group flex-1">
                            <span class="form-label">model</span>
                            <select v-model="selectedModel" class="form-select" :disabled="isSending">
                                <option v-for="model in models" :key="model.name" :value="model.name">{{ formatModelDisplay(model) }}</option>
                            </select>
                        </div>
                        <button class="form-button width-120" :disabled="isSending" @click="onFormatClick">format</button>
                        <button class="form-button width-120" :disabled="isSending" @click="onOptionsClick">options</button>
                    </div>

                    <!-- Row 2: Request textarea -->
                    <div class="textarea-container">
                        <div class="form-group" style="flex: 1; display: flex;">
                            <span class="form-label" ref="requestLabel">request</span>
                            <textarea
                                v-show="messageType === 'user'"
                                v-model="messageUser"
                                class="form-textarea"
                                placeholder="Enter your request (user message) here..."
                                spellcheck="false"
                                :disabled="isSending"
                                @scroll="onRequestScroll"
                                @input="onMessageUserInput"
                            ></textarea>
                            <textarea
                                v-show="messageType === 'system'"
                                v-model="messageSystem"
                                class="form-textarea"
                                placeholder="Enter your request (system message) here..."
                                spellcheck="false"
                                :disabled="isSending"
                                @scroll="onRequestScroll"
                                @input="onMessageSystemInput"
                            ></textarea>
                        </div>
                    </div>

                    <!-- Row 3: Load, Save, Clear and Send buttons -->
                    <div class="button-group button-group-space-between">
                        <div class="button-group">
                            <button class="form-button width-120" :disabled="isSending" @click="onLoadClick">load</button>
                            <button class="form-button width-120" :disabled="isSending" @click="onSaveClick">save</button>
                            <button class="form-button button-clear width-120" :disabled="isSending" @click="onClearClick">clear</button>
                        </div>
                        <button class="form-button width-120" :disabled="isSending" @click="onSendClick">{{ sendButtonText }}</button>
                    </div>
                </div>

                <!-- Splitter -->
                <div
                    class="splitter"
                    @mousedown="startDrag"
                    @touchstart="startDrag"
                ></div>

                <!-- Bottom section -->
                <div class="chat-bottom-section" :style="{ height: bottomHeight + 'px' }">
                    <!-- Row 5: Response textarea -->
                    <div class="textarea-container">
                        <div class="form-group" style="flex: 1; display: flex;">
                            <span class="form-label" ref="responseLabel">response</span>
                            <textarea
                                v-model="response"
                                class="form-textarea"
                                :class="responseValidationClass"
                                placeholder="Response will appear here..."
                                spellcheck="false"
                                readonly
                                @scroll="onResponseScroll"
                            ></textarea>
                        </div>
                    </div>

                    <!-- Row 6: Export buttons -->
                    <div class="button-group">
                        <button class="form-button width-220" :disabled="!responseFullData" @click="onCopyAllClick">to clipboard all</button>
                        <button class="form-button width-220" :disabled="!responseFullData" @click="onCopyPayloadClick">to clipboard payload</button>
                        <button class="form-button width-220" :disabled="!responseFullData" @click="onSaveAllClick">to file all</button>
                        <button class="form-button width-220" :disabled="!responseFullData" @click="onSavePayloadClick">to file payload</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Format Modal -->
        <div v-if="formatModalOpen" class="modal-backdrop" @click.self="onFormatCancel" @keydown.esc="onFormatCancel">
            <div class="modal-window" role="dialog" aria-labelledby="format-modal-title" aria-modal="true">
                <h2 id="format-modal-title" class="modal-title">Format Response</h2>

                <div class="modal-form-group">
                    <textarea
                        ref="formatTextarea"
                        v-model="formatSchema"
                        class="modal-textarea"
                        :class="formatValidationClass"
                        placeholder="Enter JSON Schema..."
                        spellcheck="false"
                        @input="onFormatTextareaInput"
                    ></textarea>
                    <div v-if="formatErrorMessage" class="modal-error">{{ formatErrorMessage }}</div>
                </div>

                <div class="modal-controls">
                    <div class="modal-left-controls">
                        <button class="form-button width-120" @click="onFormatCheck">check</button>
                        <div class="modal-checkbox-group" title="Convert JSON Schema to GBNF grammar to enforce valid JSON output from LLM">
                            <input
                                type="checkbox"
                                id="use-grammar"
                                v-model="formatUseGrammar"
                            />
                            <label for="use-grammar">use grammar</label>
                        </div>
                    </div>
                    <div class="modal-right-controls">
                        <button class="form-button width-120" @click="onFormatOk">ok</button>
                        <button class="form-button width-120 button-cancel" @click="onFormatCancel">cancel</button>
                    </div>
                </div>

                <div class="modal-footer">
                    <a href="https://json-schema.org/understanding-json-schema" target="_blank" class="modal-link">JSON Schema Documentation</a>
                </div>
            </div>
        </div>

        <!-- Options Modal -->
        <div v-if="optionsModalOpen" class="modal-backdrop" @click.self="onOptionsCancel" @keydown.esc="onOptionsCancel">
            <div class="modal-window" role="dialog" aria-labelledby="options-modal-title" aria-modal="true">
                <h2 id="options-modal-title" class="modal-title">LLM Options</h2>

                <div class="modal-form-group">
                    <textarea
                        ref="optionsTextarea"
                        v-model="optionsJson"
                        class="modal-textarea"
                        :class="optionsValidationClass"
                        placeholder="Enter LLM options as JSON..."
                        spellcheck="false"
                        @input="onOptionsTextareaInput"
                    ></textarea>
                    <div v-if="optionsErrorMessage" class="modal-error">{{ optionsErrorMessage }}</div>
                </div>

                <div class="modal-controls">
                    <div class="modal-left-controls">
                        <button class="form-button width-120" @click="onOptionsCheck">check</button>
                    </div>
                    <div class="modal-right-controls">
                        <button class="form-button width-120" @click="onOptionsOk">ok</button>
                        <button class="form-button width-120 button-cancel" @click="onOptionsCancel">cancel</button>
                    </div>
                </div>

                <div class="modal-footer">
                    <a href="https://docs.ollama.com/modelfile#parameter" target="_blank" class="modal-link">Ollama Model Parameters Documentation</a>
                </div>
            </div>
        </div>

        <!-- Confirm Modal -->
        <div v-if="confirmModalOpen" class="modal-backdrop" @click.self="onConfirmCancel" @keydown.esc="onConfirmCancel">
            <div class="modal-window modal-confirm" role="dialog" aria-labelledby="confirm-modal-title" aria-modal="true">
                <h2 id="confirm-modal-title" class="modal-title modal-title-warn">Confirm Action</h2>

                <div class="modal-confirm-message">
                    {{ confirmMessage }}
                </div>

                <div class="modal-controls">
                    <div class="modal-left-controls"></div>
                    <div class="modal-right-controls">
                        <button class="form-button width-120" @click="onConfirmOk">ok</button>
                        <button class="form-button width-120 button-cancel" @click="onConfirmCancel">cancel</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="/static/lib/vue.global.prod.js"></script>
    <script type="module">
        import { PromtLoad, PromtStore } from '/static/lib/vv-ai-promt-store.js'
        window.PromtLoad = PromtLoad
        window.PromtStore = PromtStore
    </script>
    <script>
        const { createApp } = Vue

        createApp({
            data() {
                return {
                    version: '0.0.0',
                    messageType: 'user',
                    selectedModel: '',
                    models: [],
                    response: '',
                    responseFullData: null, // Full response object from API
                    responseTimestamp: null, // Timestamp when response was received
                    isSending: false, // Is request being sent
                    sendStartTime: null, // When request was started
                    sendElapsedSeconds: 0, // Elapsed seconds since send started
                    sendTimerInterval: null, // Interval for updating timer
                    messageUser: '',
                    messageSystem: '',
                    responseValidationState: null, // null, 'valid', or 'invalid'
                    loadedFileName: null, // Name of loaded file
                    loadedFileHadSinglePromt: false, // Was there only one promt in loaded file
                    topHeight: 0,
                    bottomHeight: 0,
                    isDragging: false,
                    startY: 0,
                    startTopHeight: 0,
                    // Format modal state
                    formatModalOpen: false,
                    formatSchema: '',
                    formatUseGrammar: true,
                    formatValidationState: null, // null, 'valid', or 'invalid'
                    formatErrorMessage: '',
                    // Options modal state
                    optionsModalOpen: false,
                    optionsJson: '',
                    optionsValidationState: null, // null, 'valid', or 'invalid'
                    optionsErrorMessage: '',
                    // Confirm modal state
                    confirmModalOpen: false,
                    confirmMessage: '',
                    confirmCallback: null
                }
            },
            computed: {
                formatValidationClass() {
                    if (this.formatValidationState === 'valid') return 'valid'
                    if (this.formatValidationState === 'invalid') return 'invalid'
                    return ''
                },
                optionsValidationClass() {
                    if (this.optionsValidationState === 'valid') return 'valid'
                    if (this.optionsValidationState === 'invalid') return 'invalid'
                    return ''
                },
                responseValidationClass() {
                    if (this.responseValidationState === 'valid') return 'valid'
                    if (this.responseValidationState === 'invalid') return 'invalid'
                    return ''
                },
                sendButtonText() {
                    if (this.isSending) {
                        return this.formatDuration(this.sendElapsedSeconds)
                    }
                    return 'SEND'
                }
            },
            watch: {
                selectedModel(newModel) {
                    if (newModel) {
                        localStorage.setItem('chat.model', newModel)
                    }
                }
            },
            mounted() {
                // Load version
                fetch('/api/version')
                    .then(res => res.json())
                    .then(data => {
                        this.version = data.version
                    })
                    .catch(err => {
                        console.error('Failed to load version:', err)
                    })

                // Load models
                this.loadModels()

                // Initialize heights
                this.initializeHeights()

                // Add global mouse/touch event listeners
                document.addEventListener('mousemove', this.onDrag)
                document.addEventListener('mouseup', this.stopDrag)
                document.addEventListener('touchmove', this.onDrag)
                document.addEventListener('touchend', this.stopDrag)

                // Handle window resize
                window.addEventListener('resize', this.initializeHeights)

                // Handle ESC key globally
                document.addEventListener('keydown', this.handleEscKey)

                // Load messages from localStorage
                this.loadMessages()
            },
            beforeUnmount() {
                document.removeEventListener('mousemove', this.onDrag)
                document.removeEventListener('mouseup', this.stopDrag)
                document.removeEventListener('touchmove', this.onDrag)
                document.removeEventListener('touchend', this.stopDrag)
                window.removeEventListener('resize', this.initializeHeights)
                document.removeEventListener('keydown', this.handleEscKey)
            },
            methods: {
                // Helper methods
                formatTimestamp(date) {
                    if (!date) return ''
                    const year = date.getFullYear()
                    const month = String(date.getMonth() + 1).padStart(2, '0')
                    const day = String(date.getDate()).padStart(2, '0')
                    const hours = String(date.getHours()).padStart(2, '0')
                    const minutes = String(date.getMinutes()).padStart(2, '0')
                    const seconds = String(date.getSeconds()).padStart(2, '0')
                    return `${year}${month}${day}${hours}${minutes}${seconds}`
                },
                formatDuration(seconds) {
                    const hours = Math.floor(seconds / 3600)
                    const minutes = Math.floor((seconds % 3600) / 60)
                    const secs = seconds % 60

                    if (hours > 0) {
                        return `${hours} h ${minutes} min ${secs} sec`
                    } else if (minutes > 0) {
                        return `${minutes} min ${secs} sec`
                    } else {
                        return `${secs} sec`
                    }
                },
                startSendTimer() {
                    this.isSending = true
                    this.sendStartTime = Date.now()
                    this.sendElapsedSeconds = 0

                    this.sendTimerInterval = setInterval(() => {
                        this.sendElapsedSeconds = Math.floor((Date.now() - this.sendStartTime) / 1000)
                    }, 1000)
                },
                stopSendTimer() {
                    this.isSending = false
                    if (this.sendTimerInterval) {
                        clearInterval(this.sendTimerInterval)
                        this.sendTimerInterval = null
                    }
                },
                // Models
                async loadModels() {
                    try {
                        const response = await fetch('/api/models')
                        const data = await response.json()
                        this.models = data.models || []

                        // Load saved model from localStorage
                        const savedModel = localStorage.getItem('chat.model')

                        // Check if saved model exists in the list
                        if (savedModel && this.models.some(m => m.name === savedModel)) {
                            this.selectedModel = savedModel
                        } else if (this.models.length > 0) {
                            // If no saved model or saved model not found, select first
                            this.selectedModel = this.models[0].name
                        }
                    } catch (err) {
                        console.error('Failed to load models:', err)
                        this.models = []
                    }
                },
                formatModelDisplay(model) {
                    const sizeMb = Math.ceil(model.sizeKb / 1024)
                    return `${model.name} (${sizeMb} MB)`
                },
                // Messages - localStorage helpers
                loadMessages() {
                    try {
                        const savedUser = localStorage.getItem('message.user')
                        const savedSystem = localStorage.getItem('message.system')

                        this.messageUser = savedUser || ''
                        this.messageSystem = savedSystem || ''
                    } catch (err) {
                        console.error('Failed to load messages:', err)
                    }
                },
                onMessageUserInput() {
                    localStorage.setItem('message.user', this.messageUser)
                },
                onMessageSystemInput() {
                    localStorage.setItem('message.system', this.messageSystem)
                },
                // Format modal - localStorage helpers
                loadFormatSettings() {
                    try {
                        const saved = localStorage.getItem('format')
                        if (saved) {
                            const parsed = JSON.parse(saved)
                            this.formatSchema = parsed.schema || this.getDefaultSchema()
                            this.formatUseGrammar = parsed.useGrammar !== undefined ? parsed.useGrammar : true
                        } else {
                            this.formatSchema = this.getDefaultSchema()
                            this.formatUseGrammar = true
                        }
                    } catch (err) {
                        console.error('Failed to load format settings:', err)
                        this.formatSchema = this.getDefaultSchema()
                        this.formatUseGrammar = true
                    }
                },
                saveFormatSettings() {
                    try {
                        const settings = {
                            schema: this.formatSchema,
                            useGrammar: this.formatUseGrammar
                        }
                        localStorage.setItem('format', JSON.stringify(settings))
                    } catch (err) {
                        console.error('Failed to save format settings:', err)
                        if (err.name === 'QuotaExceededError') {
                            alert('Failed to save: localStorage quota exceeded. Please reduce the schema size.')
                        }
                    }
                },
                getDefaultSchema() {
                    return `{
  "type": "array",
  "items": {
    "type": "object",
    "properties": {
      "name": {
        "type": "string"
      },
      "age": {
        "type": "number"
      }
    },
    "required": ["name", "age"]
  }
}`
                },
                initializeHeights() {
                    const container = document.querySelector('.chat-container')
                    if (!container) return

                    const totalHeight = container.clientHeight
                    const splitterHeight = 8
                    const topRowsHeight = 48 + 12 + 48 + 12 // two rows + gaps
                    const bottomRowHeight = 48 + 12 // one row + gap
                    const availableHeight = totalHeight - splitterHeight - topRowsHeight - bottomRowHeight

                    // Load saved position from localStorage or use 50/50 split
                    const savedRatio = localStorage.getItem('chat-splitter-ratio')
                    const ratio = savedRatio ? parseFloat(savedRatio) : 0.5

                    this.topHeight = topRowsHeight + (availableHeight * ratio)
                    this.bottomHeight = bottomRowHeight + (availableHeight * (1 - ratio))
                },
                startDrag(e) {
                    this.isDragging = true
                    this.startY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY
                    this.startTopHeight = this.topHeight
                    e.preventDefault()
                },
                onDrag(e) {
                    if (!this.isDragging) return

                    const currentY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY
                    const deltaY = currentY - this.startY

                    const container = document.querySelector('.chat-container')
                    const totalHeight = container.clientHeight
                    const splitterHeight = 8
                    const topRowsHeight = 48 + 12 + 48 + 12
                    const bottomRowHeight = 48 + 12
                    const availableHeight = totalHeight - splitterHeight - topRowsHeight - bottomRowHeight

                    let newTopHeight = this.startTopHeight + deltaY
                    let newBottomHeight = totalHeight - newTopHeight - splitterHeight

                    // Calculate ratio for the available (textarea) space
                    const topTextareaHeight = newTopHeight - topRowsHeight
                    const ratio = topTextareaHeight / availableHeight

                    // Enforce ratio limits: 0.2 to 0.8
                    if (ratio < 0.2) {
                        newTopHeight = topRowsHeight + (availableHeight * 0.2)
                        newBottomHeight = totalHeight - newTopHeight - splitterHeight
                    } else if (ratio > 0.8) {
                        newTopHeight = topRowsHeight + (availableHeight * 0.8)
                        newBottomHeight = totalHeight - newTopHeight - splitterHeight
                    }

                    this.topHeight = newTopHeight
                    this.bottomHeight = newBottomHeight
                },
                stopDrag() {
                    if (this.isDragging) {
                        this.isDragging = false
                        this.saveSplitterPosition()
                    }
                },
                saveSplitterPosition() {
                    const container = document.querySelector('.chat-container')
                    const totalHeight = container.clientHeight
                    const topRowsHeight = 48 + 12 + 48 + 12
                    const bottomRowHeight = 48 + 12
                    const availableHeight = totalHeight - 8 - topRowsHeight - bottomRowHeight

                    const ratio = (this.topHeight - topRowsHeight) / availableHeight
                    localStorage.setItem('chat-splitter-ratio', ratio.toString())
                },
                onFormatClick() {
                    this.loadFormatSettings()
                    this.formatValidationState = null
                    this.formatErrorMessage = ''
                    this.formatModalOpen = true

                    this.$nextTick(() => {
                        if (this.$refs.formatTextarea) {
                            this.$refs.formatTextarea.focus()
                        }
                    })
                },
                async onFormatCheck() {
                    try {
                        const schema = JSON.parse(this.formatSchema)

                        const response = await fetch('/api/checkformat', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ schema }),
                        })

                        const result = await response.json()

                        if (result.error) {
                            this.formatValidationState = 'invalid'
                            this.formatErrorMessage = result.error
                        } else {
                            this.formatValidationState = 'valid'
                            this.formatErrorMessage = ''
                        }
                    } catch (err) {
                        this.formatValidationState = 'invalid'
                        this.formatErrorMessage = err.message || 'Failed to validate schema'
                    }
                },
                onFormatTextareaInput() {
                    this.formatValidationState = null
                    this.formatErrorMessage = ''
                },
                onFormatOk() {
                    this.saveFormatSettings()
                    this.formatModalOpen = false
                },
                onFormatCancel() {
                    this.formatModalOpen = false
                    this.formatValidationState = null
                    this.formatErrorMessage = ''
                },
                // Options modal - localStorage helpers
                loadOptionsSettings() {
                    try {
                        const saved = localStorage.getItem('options')
                        if (saved) {
                            this.optionsJson = saved
                        } else {
                            this.optionsJson = this.getDefaultOptions()
                        }
                    } catch (err) {
                        console.error('Failed to load options settings:', err)
                        this.optionsJson = this.getDefaultOptions()
                    }
                },
                saveOptionsSettings() {
                    try {
                        localStorage.setItem('options', this.optionsJson)
                    } catch (err) {
                        console.error('Failed to save options settings:', err)
                        if (err.name === 'QuotaExceededError') {
                            alert('Failed to save: localStorage quota exceeded. Please reduce the options size.')
                        }
                    }
                },
                getDefaultOptions() {
                    return `{
  "temperature": 0.0,
  "topP": 0.1,
  "topK": 10,
  "minP": 0.0,
  "maxTokens": 4096,
  "repeatPenalty": 1.0,
  "repeatPenaltyNum": 0,
  "presencePenalty": 0.0,
  "frequencyPenalty": 0.0,
  "mirostat": 0,
  "mirostatTau": 5.0,
  "mirostatEta": 0.1,
  "penalizeNewline": false,
  "stopSequences": [],
  "trimWhitespace": true,
  "seed": null,
  "tokenBias": null,
  "evaluationPriority": null,
  "contextShiftSize": null,
  "disableContextShift": null
}`
                },
                onOptionsClick() {
                    this.loadOptionsSettings()
                    this.optionsValidationState = null
                    this.optionsErrorMessage = ''
                    this.optionsModalOpen = true

                    this.$nextTick(() => {
                        if (this.$refs.optionsTextarea) {
                            this.$refs.optionsTextarea.focus()
                        }
                    })
                },
                async onOptionsCheck() {
                    try {
                        const options = JSON.parse(this.optionsJson)

                        const response = await fetch('/api/checkoptions', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ options }),
                        })

                        const result = await response.json()

                        if (result.error) {
                            this.optionsValidationState = 'invalid'
                            this.optionsErrorMessage = result.error
                            // Update textarea with completed options even if there's an error
                            this.optionsJson = JSON.stringify(result.options, null, 2)
                        } else {
                            this.optionsValidationState = 'valid'
                            this.optionsErrorMessage = ''
                            // Update textarea with completed options
                            this.optionsJson = JSON.stringify(result.options, null, 2)
                        }
                    } catch (err) {
                        this.optionsValidationState = 'invalid'
                        this.optionsErrorMessage = err.message || 'Failed to validate options'
                    }
                },
                onOptionsTextareaInput() {
                    this.optionsValidationState = null
                    this.optionsErrorMessage = ''
                },
                onOptionsOk() {
                    this.saveOptionsSettings()
                    this.optionsModalOpen = false
                },
                onOptionsCancel() {
                    this.optionsModalOpen = false
                    this.optionsValidationState = null
                    this.optionsErrorMessage = ''
                },
                onLoadClick() {
                    // Create file input element
                    const input = document.createElement('input')
                    input.type = 'file'
                    input.accept = '.txt,.promt'

                    input.onchange = async (e) => {
                        const file = e.target.files[0]
                        if (!file) return

                        try {
                            // Read file content
                            const content = await file.text()

                            // Parse with PromtLoad
                            const promts = window.PromtLoad(content)

                            if (!promts || promts.length === 0) {
                                alert('No prompts found in file')
                                return
                            }

                            // Use first promt
                            const promt = promts[0]

                            // Load messages
                            this.messageUser = promt.user || ''
                            this.messageSystem = promt.system || ''

                            // Save messages to localStorage
                            localStorage.setItem('message.user', this.messageUser)
                            localStorage.setItem('message.system', this.messageSystem)

                            // Load format from segment.format
                            if (promt.segment && promt.segment.format) {
                                try {
                                    // Parse format object from file
                                    const formatObj = JSON.parse(promt.segment.format)

                                    // If schema is an object, convert it to formatted string for localStorage
                                    if (formatObj.schema && typeof formatObj.schema === 'object') {
                                        formatObj.schema = JSON.stringify(formatObj.schema, null, 4)
                                    }

                                    // Save to localStorage
                                    localStorage.setItem('format', JSON.stringify(formatObj))
                                } catch (err) {
                                    console.error('Failed to save format segment:', err)
                                }
                            }

                            // Load options from options field and merge with defaults
                            try {
                                // Parse default options
                                const defaultOptions = JSON.parse(this.getDefaultOptions())

                                // Merge loaded options with defaults (loaded options override defaults)
                                const mergedOptions = { ...defaultOptions, ...promt.options }

                                localStorage.setItem('options', JSON.stringify(mergedOptions, null, 2))
                            } catch (err) {
                                console.error('Failed to save options:', err)
                            }

                            // Load model from segment.model (if found in models list)
                            if (promt.segment && promt.segment.model) {
                                const modelName = promt.segment.model.trim()
                                if (this.models.some(m => m.name === modelName)) {
                                    this.selectedModel = modelName
                                } else {
                                    console.warn(`Model "${modelName}" not found, keeping current selection`)
                                }
                            }

                            // Load grammar from prompt
                            if (promt.grammar) {
                                try {
                                    this.formatSchema = promt.grammar
                                    this.formatUseGrammar = true
                                } catch (err) {
                                    console.error('Failed to load grammar from prompt:', err)
                                }
                            }

                            // Track loaded file
                            this.loadedFileName = file.name
                            this.loadedFileHadSinglePromt = promts.length === 1

                            console.log('Promt loaded successfully from', file.name)
                        } catch (err) {
                            alert('Failed to load promt: ' + err.message)
                            console.error('Load error:', err)
                        }
                    }

                    input.click()
                },
                onSaveClick() {
                    try {
                        // Create promt object
                        const promt = {
                            user: this.messageUser,
                            system: this.messageSystem || undefined,
                            segment: {},
                            options: undefined
                        }

                        // Add format segment if exists (with pretty formatting)
                        try {
                            const savedFormat = localStorage.getItem('format')
                            if (savedFormat) {
                                // Parse format object
                                const formatObj = JSON.parse(savedFormat)

                                // If schema exists and is a string, parse it to object
                                if (formatObj.schema && typeof formatObj.schema === 'string') {
                                    try {
                                        formatObj.schema = JSON.parse(formatObj.schema)
                                    } catch (e) {
                                        // If schema is not valid JSON, keep as is
                                    }
                                }

                                // Stringify the whole format object with indentation
                                // Now schema will be formatted as nested object, not as string
                                promt.segment.format = JSON.stringify(formatObj, null, 4)
                            }
                        } catch (err) {
                            console.error('Failed to load format for saving:', err)
                        }

                        // Add options if exists
                        try {
                            const savedOptions = localStorage.getItem('options')
                            if (savedOptions) {
                                promt.options = JSON.parse(savedOptions)
                            }
                        } catch (err) {
                            console.error('Failed to load options for saving:', err)
                        }

                        // Add model segment if exists
                        if (this.selectedModel) {
                            promt.segment.model = this.selectedModel
                        }

                        // Add grammar if useGrammar is enabled
                        if (this.formatUseGrammar && this.formatSchema && this.formatSchema.trim().length > 0) {
                            try {
                                // Validate that it's valid JSON
                                JSON.parse(this.formatSchema)
                                promt.grammar = this.formatSchema
                            } catch (err) {
                                console.error('Failed to add grammar to prompt (invalid JSON):', err)
                            }
                        }

                        // Serialize with PromtStore
                        const content = window.PromtStore([promt])

                        // Determine filename
                        let filename
                        if (this.loadedFileName && this.loadedFileHadSinglePromt) {
                            // Reuse loaded filename
                            filename = this.loadedFileName
                        } else {
                            // Generate new filename with timestamp
                            const timestamp = this.formatTimestamp(new Date())
                            filename = `promt-${timestamp}.txt`
                        }

                        // Download file
                        const blob = new Blob([content], { type: 'text/plain' })
                        const url = URL.createObjectURL(blob)
                        const a = document.createElement('a')
                        a.href = url
                        a.download = filename
                        document.body.appendChild(a)
                        a.click()
                        document.body.removeChild(a)
                        URL.revokeObjectURL(url)

                        console.log('Promt saved to', filename)
                    } catch (err) {
                        alert('Failed to save promt: ' + err.message)
                        console.error('Save error:', err)
                    }
                },
                onClearClick() {
                    this.showConfirm('Are you sure you want to clear all data?', () => {
                        // Clear messages
                        this.messageUser = ''
                        this.messageSystem = ''
                        localStorage.setItem('message.user', '')
                        localStorage.setItem('message.system', '')

                        // Reset to first model
                        if (this.models.length > 0) {
                            this.selectedModel = this.models[0].name
                        }

                        // Reset format to defaults
                        const defaultFormat = {
                            schema: this.getDefaultSchema(),
                            useGrammar: true
                        }
                        localStorage.setItem('format', JSON.stringify(defaultFormat))

                        // Reset options to defaults
                        localStorage.setItem('options', this.getDefaultOptions())

                        // Clear response
                        this.response = ''
                        this.responseFullData = null
                        this.responseTimestamp = null
                        this.responseValidationState = null

                        // Clear loaded file tracking
                        this.loadedFileName = null
                        this.loadedFileHadSinglePromt = false

                        console.log('All data cleared')
                    })
                },
                showConfirm(message, callback) {
                    this.confirmMessage = message
                    this.confirmCallback = callback
                    this.confirmModalOpen = true
                },
                onConfirmOk() {
                    this.confirmModalOpen = false
                    if (this.confirmCallback) {
                        this.confirmCallback()
                        this.confirmCallback = null
                    }
                    this.confirmMessage = ''
                },
                onConfirmCancel() {
                    this.confirmModalOpen = false
                    this.confirmCallback = null
                    this.confirmMessage = ''
                },
                async onSendClick() {
                    if (this.isSending) return

                    // Start timer
                    this.startSendTimer()

                    // Reset response state
                    this.responseValidationState = null
                    this.response = ''
                    this.responseFullData = null
                    this.responseTimestamp = null

                    try {
                        // Load format settings from localStorage
                        let formatSettings = null
                        try {
                            const savedFormat = localStorage.getItem('format')
                            if (savedFormat) {
                                const parsed = JSON.parse(savedFormat)
                                formatSettings = {
                                    useGrammar: parsed.useGrammar,
                                    jsonSchema: JSON.parse(parsed.schema)
                                }
                            }
                        } catch (err) {
                            console.error('Failed to parse format settings:', err)
                        }

                        // Load options from localStorage
                        let options = null
                        try {
                            const savedOptions = localStorage.getItem('options')
                            if (savedOptions) {
                                options = JSON.parse(savedOptions)
                            }
                        } catch (err) {
                            console.error('Failed to parse options:', err)
                        }

                        // Prepare request body
                        const requestBody = {
                            model: this.selectedModel,
                            message: {
                                user: this.messageUser,
                                system: this.messageSystem || undefined
                            },
                            durationMsec: 3600000, // 1 hour
                            options: options || undefined,
                            format: formatSettings || undefined
                        }

                        // Send request to API
                        const response = await fetch('/promt', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(requestBody),
                        })

                        const result = await response.json()

                        // Store full response data and timestamp
                        this.responseFullData = result
                        this.responseTimestamp = new Date()

                        // Handle response - show entire response object
                        if (response.ok && result.result && result.result.data !== undefined) {
                            // Success - show full PromtResponseDto
                            this.response = JSON.stringify(result, null, 2)
                            this.responseValidationState = 'valid'
                        } else {
                            // Error - show full PromtResponseBadDto
                            this.response = JSON.stringify(result, null, 2)
                            this.responseValidationState = 'invalid'
                        }
                    } catch (err) {
                        // Network or other error
                        this.response = `Error: ${err.message}`
                        this.responseValidationState = 'invalid'
                        this.responseFullData = null
                        this.responseTimestamp = null
                    } finally {
                        // Stop timer
                        this.stopSendTimer()
                    }
                },
                onCopyAllClick() {
                    if (!this.responseFullData) return

                    const text = JSON.stringify(this.responseFullData, null, 2)
                    navigator.clipboard.writeText(text).then(() => {
                        console.log('Copied all to clipboard')
                    }).catch(err => {
                        console.error('Failed to copy to clipboard:', err)
                    })
                },
                onCopyPayloadClick() {
                    if (!this.responseFullData) return

                    let payload
                    if (this.responseValidationState === 'valid' && this.responseFullData.result && this.responseFullData.result.data !== undefined) {
                        // Success case: copy result.data
                        payload = this.responseFullData.result.data
                    } else if (this.responseFullData.error) {
                        // Error case: copy error
                        payload = this.responseFullData.error
                    } else {
                        // Fallback: copy everything
                        payload = this.responseFullData
                    }

                    const text = typeof payload === 'string' ? payload : JSON.stringify(payload, null, 2)
                    navigator.clipboard.writeText(text).then(() => {
                        console.log('Copied payload to clipboard')
                    }).catch(err => {
                        console.error('Failed to copy to clipboard:', err)
                    })
                },
                onSaveAllClick() {
                    if (!this.responseFullData) return

                    const timestamp = this.formatTimestamp(this.responseTimestamp)
                    const text = JSON.stringify(this.responseFullData, null, 2)
                    const blob = new Blob([text], { type: 'application/json' })
                    const url = URL.createObjectURL(blob)
                    const a = document.createElement('a')
                    a.href = url
                    a.download = `response-all-${timestamp}.json`
                    document.body.appendChild(a)
                    a.click()
                    document.body.removeChild(a)
                    URL.revokeObjectURL(url)
                },
                onSavePayloadClick() {
                    if (!this.responseFullData) return

                    const timestamp = this.formatTimestamp(this.responseTimestamp)
                    let payload
                    let filename
                    if (this.responseValidationState === 'valid' && this.responseFullData.result && this.responseFullData.result.data !== undefined) {
                        // Success case: save result.data
                        payload = this.responseFullData.result.data
                        filename = `response-data-${timestamp}.json`
                    } else if (this.responseFullData.error) {
                        // Error case: save error
                        payload = this.responseFullData.error
                        filename = `response-error-${timestamp}.txt`
                    } else {
                        // Fallback: save everything
                        payload = this.responseFullData
                        filename = `response-${timestamp}.json`
                    }

                    const text = typeof payload === 'string' ? payload : JSON.stringify(payload, null, 2)
                    const blob = new Blob([text], { type: typeof payload === 'string' ? 'text/plain' : 'application/json' })
                    const url = URL.createObjectURL(blob)
                    const a = document.createElement('a')
                    a.href = url
                    a.download = filename
                    document.body.appendChild(a)
                    a.click()
                    document.body.removeChild(a)
                    URL.revokeObjectURL(url)
                },
                onRequestScroll(e) {
                    const scrollTop = e.target.scrollTop
                    if (this.$refs.requestLabel) {
                        this.$refs.requestLabel.style.opacity = scrollTop > 0 ? '0' : '1'
                    }
                },
                onResponseScroll(e) {
                    const scrollTop = e.target.scrollTop
                    if (this.$refs.responseLabel) {
                        this.$refs.responseLabel.style.opacity = scrollTop > 0 ? '0' : '1'
                    }
                },
                handleEscKey(e) {
                    if (e.key === 'Escape') {
                        if (this.confirmModalOpen) {
                            this.onConfirmCancel()
                        } else if (this.formatModalOpen) {
                            this.onFormatCancel()
                        } else if (this.optionsModalOpen) {
                            this.onOptionsCancel()
                        }
                    }
                }
            }
        }).mount('#app')
    </script>
</body>
</html>
